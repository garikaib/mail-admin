#!/usr/bin/env python3
"""
Generate and send daily email usage report using pflogsum.
Target recipients: garikaib@gmail.com, garikai@zimpricecheck.com
Schedule: Daily at 8:00 Africa/Harare (06:00 UTC)
"""

import subprocess
import datetime
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

RECIPIENTS = ["garikaib@gmail.com", "garikai@zimpricecheck.com"]
SUBJECT = f"Daily Email Usage Report - {datetime.date.today() - datetime.timedelta(days=1)}"
LOG_FILE = "/var/log/mail.log.1" # Analysis for the previous day (log rotated daily)

# Fallback to current log if rotated log doesn't exist
import os
if not os.path.exists(LOG_FILE):
    LOG_FILE = "/var/log/mail.log"

def get_pflogsum_report():
    # Use journalctl to get yesterday's logs in traditional syslog format
    # This is much more reliable than parsing ISO 8601 files directly
    cmd = "sudo journalctl --since yesterday --until today --output=short | pflogsumm"
    
    try:
        # Run via shell to support piping
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True, check=True)
        return result.stdout
    except subprocess.CalledProcessError as e:
        return f"Error running pflogsumm via journalctl: {e}\nOutput: {e.output}\nStderr: {e.stderr}"
    except Exception as e:
        return f"Unexpected error: {str(e)}"

def parse_top_senders(report_text, limit=10):
    lines = report_text.splitlines()
    senders = []
    in_senders_section = False
    
    for line in lines:
        if "senders by message count" in line.lower():
            in_senders_section = True
            continue
        if in_senders_section and "recipients by message count" in line.lower():
            in_senders_section = False
            break
        
        if in_senders_section and line.strip():
            # Example line: "    123   user@domain.com"
            parts = line.split()
            if len(parts) >= 2 and parts[0].isdigit():
                senders.append((int(parts[0]), parts[1]))
    
    # Sort by count descending and take top N
    senders.sort(key=lambda x: x[0], reverse=True)
    return senders[:limit]

def format_html_table(senders):
    html = """
    <html>
    <head>
    <style>
        table { border-collapse: collapse; width: 100%; max_width: 600px; }
        th, td { text-align: left; padding: 8px; border-bottom: 1px solid #ddd; }
        th { background-color: #f2f2f2; }
    </style>
    </head>
    <body>
    <h2>Top 10 Email Senders (Yesterday)</h2>
    <table>
      <tr>
        <th>Count</th>
        <th>Sender Address</th>
      </tr>
    """
    
    for count, email in senders:
        html += f"<tr><td>{count}</td><td>{email}</td></tr>"
    
    html += """
    </table>
    <p>Generated by pflogsumm report.</p>
    </body>
    </html>
    """
    return html

def send_email(html_content):
    msg = MIMEMultipart("alternative")
    msg["Subject"] = SUBJECT
    msg["From"] = "reports@mail.zimprices.co.zw"
    msg["To"] = ", ".join(RECIPIENTS)

    part = MIMEText(html_content, "html")
    msg.attach(part)

    try:
        # Send via local postfix
        with smtplib.SMTP("localhost") as s:
            s.send_message(msg)
        print("✅ Report sent successfully.")
    except Exception as e:
        print(f"❌ Failed to send email: {e}")

def main():
    report = get_pflogsum_report()
    top_senders = parse_top_senders(report)
    
    if not top_senders:
        print("No stats found for yesterday.")
        html_report = "<html><body><h2>No email stats found for yesterday.</h2></body></html>"
    else:
        html_report = format_html_table(top_senders)
    
    send_email(html_report)
    # print(report) # Debug: print full report to stdout

if __name__ == "__main__":
    main()
